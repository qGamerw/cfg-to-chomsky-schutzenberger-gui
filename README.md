# Grammar → Chomsky–Schützenberger Converter (Tkinter)

GUI-приложение на Python (Tkinter), которое:
1) парсит **КС-грамматику** (context-free grammar, CFG),
2) строит **представление Хомского–Шютценбергера**:  
   **L = h(R ∩ Dyck_Γ)**,
3) (опционально) строит **дерево разбора** для заданной входной строки.

---

## Возможности

- Ввод грамматики в виде правил `A -> ... | ...`
- Поддержка ε-продукций (пустая строка): `ε` или `epsilon`
- Авто-определение:
  - `N` (нетерминалы) — по левым частям правил
  - `Σ` (терминалы) — символы RHS, которых нет в `N`
- Вывод:
  - алфавит стека `K = N ∪ Σ ∪ {⊥}`
  - скобочный алфавит `Γ` (по паре скобок на каждый символ из `K`)
  - регулярный фильтр `R` в “regex-подобной” записи (через `STEP`)
  - гомоморфизм `h`
  - дерево разбора (если введена строка)

---

## Формат грамматики

Каждая строка — правило:

```

S -> a S b | A
A -> a A | ε

```

### Токенизация RHS (важно)

- Если в RHS **есть пробелы** — разбор идёт **по токенам**:
```

S -> a S b

```
распознаётся как `["a", "S", "b"]`

- Если пробелов **нет** — разбор идёт **по символам**:
```

S -> aSb

````
распознаётся как `["a", "S", "b"]`

Это удобно, но может удивить: `id` без пробелов превратится в `["i", "d"]`.
Если используешь многосимвольные токены (`id`, `NUM`, `expr`) — **ставь пробелы**.

---

## Дерево разбора

В поле **"Входная строка"** можно указать строку, для которой приложение попробует построить дерево разбора.

Токенизация входной строки:
- если есть пробелы → по пробелам (`"a a b b"` → `["a","a","b","b"]`)
- если нет пробелов → по символам (`"aabb"` → `["a","a","b","b"]`)

Есть ограничение глубины/шагов поиска (чтобы не уйти в бесконечность на рекурсивных грамматиках).

---

## Запуск

Требования:
- Python 3.10+ (обычно подойдёт и 3.8+, если Tkinter установлен)
- Tkinter (в Windows обычно уже есть, в Linux может ставиться отдельно)

Запуск:

```bash
python main.py
````

---

## Структура проекта

* `main.py` — точка входа: создаёт `tk.Tk()` и запускает GUI
* `ui.py` — интерфейс (Tkinter): ввод грамматики/строки, кнопки примеров, вывод результата
* `grammar.py` — парсер грамматики:

  * `parse_grammar(text)` → `Grammar`
  * `GrammarError` — ошибки с номером строки
* `cs_representation.py` — построение представления Хомского–Шютценбергера:

  * `build_cs_representation(grammar)` → `CSRepresentation`
  * `format_cs_output(grammar, cs_rep, parse_tree=None)` — форматированный вывод
* `parse_tree.py` — дерево разбора:

  * `parse_string(grammar, input_text)` → `ParseNode` (или `None`)
  * `format_parse_tree(node)` — печать дерева

---

## Примеры

В GUI есть кнопки **Пример 1** и **Пример 2** — они подставляют готовые грамматики и строку для разбора.

---

## Ограничения и заметки

* Проект учебный: представление строится корректно, но не оптимизируется (не минимизируется).
* Разбор строки — перебор с мемоизацией и лимитами: на некоторых грамматиках может не найти разбор, даже если он существует.
* Для многосимвольных терминалов/нетерминалов используй пробелы в RHS.